# -*- coding: utf-8 -*-
"""CarguePostgres.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vuaPaVYIuFXtLwiLNP_3-A2k7ur2lI3K

Conexi√≥n a la base de datos
"""

!pip install unidecode

!pip install eralchemy
!apt-get install -y graphviz

from sqlalchemy import create_engine

# üîÅ Reemplaza estas variables por las de tu base en Render
db_user = "_usrvial"
db_password = "h5WPWwNObB9xIsHZK2b6OgKQpGHzgzMO"
db_host = "dpg-d0jc886uk2gs73bnkg0g-a.oregon-postgres.render.com"
db_port = "5432"
db_name = "postgres_instance_pv9g"

# Conexi√≥n con SQLAlchemy
engine = create_engine(f"postgresql+psycopg2://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}")
db_uri=f"postgresql+psycopg2://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}"
#postgresql://_usrvial:h5WPWwNObB9xIsHZK2b6OgKQpGHzgzMO@dpg-d0jc886uk2gs73bnkg0g-a.oregon-postgres.render.com/postgres_instance_pv9g
conn = engine.connect()

# Generar el archivo intermedio .er con la estructura del modelo
!eralchemy -i "$db_uri" -o modelo.er --exclude-tables alembic_version
# Convertir el modelo a PDF
!eralchemy -i modelo.er -o modelo.pdf
from google.colab import files
files.download("modelo.pdf")

"""ELIMINACION TABLAS"""

from sqlalchemy import create_engine, text

# Lista de tablas a eliminar
#tablas = ['tramos', 'peajes', 'recaudo', 'tarifas']
#tablas = ['tramos', 'peajes', 'recaudo']
tablas = ['peajes', 'recaudo', 'tarifas']

tablas = ['tarifas', 'recaudo', 'peajes']

with engine.begin() as conn:  # <-- esto asegura commit autom√°tico
    for tabla in tablas:
        try:
            conn.execute(text(f"DROP TABLE IF EXISTS {tabla} CASCADE;"))
            print(f"‚úÖ Tabla '{tabla}' eliminada correctamente.")
        except Exception as e:
            print(f"‚ùå Error al eliminar la tabla '{tabla}': {e}")

"""CREACION TABLAS"""

from sqlalchemy import create_engine, text
"""
CREATE TABLE IF NOT EXISTS tramos (
    id_tramo SERIAL PRIMARY KEY,
    codigo_tramo TEXT,
    nombretramo TEXT,
    nombre_ruta TEXT,
    calzada TEXT,
    sector TEXT,
    categoria TEXT
);
"""

sql_script = """

CREATE TABLE IF NOT EXISTS peajes (
    id_peaje SERIAL PRIMARY KEY,
    codigo_del_peaje TEXT,
    nombre_del_peaje TEXT NOT NULL,
    ubicacion TEXT,
    sector TEXT,
    sentido TEXT,
    id_tramo INT REFERENCES tramos(id_tramo) ON DELETE SET NULL,
    responsable TEXT
);

CREATE TABLE IF NOT EXISTS recaudo (
    id_recaudo SERIAL PRIMARY KEY,
    id_peaje INT NOT NULL REFERENCES peajes(id_peaje) ON DELETE CASCADE,
    desde DATE NOT NULL,
    hasta DATE NOT NULL,
    cantidadtrafico INT,
    categoriatarifa TEXT,
    valortarifa NUMERIC(14,2),
    cantidadexentos787 INT
);
"""

# Ejecutar cada sentencia con seguridad
with engine.begin() as conn:
    for stmt in sql_script.strip().split(';'):
        if stmt.strip():
            try:
                conn.execute(text(stmt))
                print(f"‚úÖ Ejecutado: {stmt.strip().splitlines()[0]}")
            except Exception as e:
                print("‚ùå Error ejecutando sentencia:", e)


with engine.connect() as conn:
    result = conn.execute(text("""
        SELECT tablename FROM pg_tables WHERE schemaname = 'public';
    """)).fetchall()

print("üìã Tablas creadas:")
for row in result:
    print("-", row[0])

"""CARGUE DE INFORMACION

CARGAR TRAMOS
"""

from google.colab import files
import pandas as pd
from sqlalchemy import create_engine, text

# Subir CSV - RedVialODAGOL_-3247446118488615697
uploaded = files.upload()
filename = next(iter(uploaded))
df = pd.read_csv(filename)

# Normalizar columnas
df.columns = df.columns.str.strip().str.lower().str.replace(' ', '_').str.replace(r'[^\w_]', '', regex=True)
print("HOLA ", df.columns.tolist())

df = df.fillna('N/D')

# Convertir columnas num√©ricas a texto para que coincidan con los tipos SQL
df['calzada'] = df['calzada'].astype(str)
df['codigo_tramo'] = df['codigo_tramo'].astype(str)
df['categoria'] = df['categoria'].astype(str)
df['nombre_ruta'] = df['nombre_ruta'].astype(str)
df['sector'] = df['sector'].astype(str)

# Renombrar columnas para coincidir con la tabla SQL
df = df.rename(columns={
    'codigo_tramo': 'codigo_tramo',
    'nombre_tramo': 'nombretramo',
    'nombre_ruta': 'nombre_ruta',
    'calzada': 'calzada',
    'sector': 'sector',
    'categoria': 'categoria'
})

# Filtrar columnas necesarias
df = df[['codigo_tramo', 'nombretramo', 'nombre_ruta', 'calzada', 'sector', 'categoria']]

# Eliminar duplicados dentro del archivo
df = df.drop_duplicates()

# Insertar solo si no existe ya en la base
insertados = 0
with engine.connect() as conn:
    for _, row in df.iterrows():
        values = row.to_dict()
        # Verificar si ya existe
        consulta = """
        SELECT COUNT(*) FROM tramos
        WHERE
            codigo_tramo = :codigo_tramo AND
            nombretramo = :nombretramo AND
            nombre_ruta = :nombre_ruta AND
            calzada = :calzada AND
            sector = :sector AND
            categoria = :categoria
        """
        existe = conn.execute(text(consulta), values).scalar()
        if existe == 0:
            # Insertar si no existe
            df_unico = pd.DataFrame([values])
            df_unico.to_sql("tramos", engine, if_exists="append", index=False)
            insertados += 1

print(f"‚úÖ {insertados} tramos √∫nicos cargados.")

"""CARGAR PEAJES"""

from google.colab import files
import pandas as pd
from sqlalchemy import create_engine, text
from unidecode import unidecode

# Subir Excel - PeajesODAGOL_5229838553902514777
uploaded = files.upload()
filename = next(iter(uploaded))
df = pd.read_excel(filename)

# Normalizar columnas
df.columns = df.columns.map(lambda col: unidecode(col.strip().lower().replace(' ', '_')))
df.columns = df.columns.str.replace(r'[^\w_]', '', regex=True)

# Reemplazar valores nulos
df = df.fillna('N/D')

# Conexi√≥n a BD
# Aseg√∫rate de tener la variable `engine` ya creada con create_engine()

# 1Ô∏è‚É£ Verificar existencia de 'codigo_tramo'
if 'codigo_tramo' not in df.columns:
    raise ValueError("‚ùå La columna 'codigo_tramo' no est√° presente en el archivo de peajes.")

# 3Ô∏è‚É£ Agregar tramo ficticio si no existe
with engine.begin() as conn:
    conn.execute(text("""
        INSERT INTO tramos (id_tramo, codigo_tramo, nombretramo, nombre_ruta, calzada, sector, categoria)
        SELECT 0, '0000', 'No Tiene', 'N/D', 'N/D', 'N/D', 'N/D'
        WHERE NOT EXISTS (
            SELECT 1 FROM tramos WHERE id_tramo = 0
        );
    """))
print("üß© Tramo ficticio 'No Tiene' verificado o creado.")

# 2Ô∏è‚É£ Cargar tramos desde BD
with engine.connect() as conn:
    df_tramos = pd.read_sql("SELECT id_tramo, codigo_tramo FROM tramos", conn)

# 4Ô∏è‚É£ Hacer merge por codigo_tramo
df_merged = df.merge(df_tramos, on='codigo_tramo', how='left')

# 5Ô∏è‚É£ Asignar tramo 0 si no encuentra uno v√°lido
df_merged['id_tramo'] = df_merged['id_tramo'].fillna(0).astype(int)

# 6Ô∏è‚É£ Verificar columnas requeridas
columnas_necesarias = ['codigo_del_peaje', 'nombre_del_peaje', 'ubicacion', 'sector', 'sentido', 'responsable']
for col in columnas_necesarias:
    if col not in df_merged.columns:
        raise ValueError(f"‚ùå Falta la columna requerida: {col}")

# 7Ô∏è‚É£ Filtrar columnas y agregar id_tramo
df_peajes_final = df_merged[['codigo_del_peaje', 'nombre_del_peaje', 'ubicacion', 'sector', 'sentido', 'responsable', 'id_tramo']]

# 8Ô∏è‚É£ Subir a tabla peajes
df_peajes_final.to_sql("peajes", engine, if_exists="append", index=False)
print(f"‚úÖ {len(df_peajes_final)} peajes insertados correctamente, incluyendo los que usan tramo 'No Tiene'.")

"""CARGUE HISTORICO TARIFAS - RECAUDO"""

from google.colab import files
import pandas as pd
from sqlalchemy import create_engine, text
from unidecode import unidecode

# 2Ô∏è‚É£ Subir archivo CSV - Tr_fico_Vehicular_ANI_20250516
uploaded = files.upload()
filename = next(iter(uploaded))
df = pd.read_csv(filename, low_memory=False)

# 3Ô∏è‚É£ Normalizar columnas
df.columns = df.columns.map(lambda c: unidecode(c.strip().lower().replace(' ', '_')))
df.columns = df.columns.str.replace(r'[^\w_]', '', regex=True)

print("üìÑ Columnas detectadas:", df.columns.tolist())
print(f"üìÑ Registros originales en CSV: {len(df)}")

# 4Ô∏è‚É£ Normalizar c√≥digo de peaje
def normalizar_codigo(valor):
    try:
        return str(int(float(valor)))
    except:
        return str(valor).strip().upper()

df['codigo_peaje_normalizado'] = df['idpeaje'].apply(normalizar_codigo)

# 5Ô∏è‚É£ Leer peajes existentes
with engine.connect() as conn:
    df_peajes = pd.read_sql("SELECT id_peaje, codigo_del_peaje FROM peajes", conn)
df_peajes['codigo_peaje_normalizado'] = df_peajes['codigo_del_peaje'].apply(normalizar_codigo)
df_peajes = df_peajes.drop_duplicates(subset='codigo_peaje_normalizado')

# 6Ô∏è‚É£ Detectar peajes que no existen y agregarlos
peajes_nuevos = df[~df['codigo_peaje_normalizado'].isin(df_peajes['codigo_peaje_normalizado'])][['codigo_peaje_normalizado']].drop_duplicates()
print(f"‚ûï Peajes nuevos por insertar: {len(peajes_nuevos)}")

# Crear DataFrame con columnas obligatorias
peajes_nuevos['codigo_del_peaje'] = peajes_nuevos['codigo_peaje_normalizado']
peajes_nuevos['nombre_del_peaje'] = 'SIN NOMBRE'
peajes_nuevos['ubicacion'] = 'N/D'
peajes_nuevos['sector'] = 'N/D'
peajes_nuevos['sentido'] = 'N/D'
peajes_nuevos['id_tramo'] = 0
peajes_nuevos['responsable'] = 'N/D'

# Insertar nuevos peajes
with engine.begin() as conn:
    peajes_nuevos[['codigo_del_peaje', 'nombre_del_peaje', 'ubicacion', 'sector', 'sentido', 'id_tramo', 'responsable']].to_sql(
        "peajes", con=conn, if_exists="append", index=False
    )
    print("‚úÖ Peajes nuevos insertados correctamente.")

# 7Ô∏è‚É£ Recargar df_peajes ya con los nuevos
with engine.connect() as conn:
    df_peajes = pd.read_sql("SELECT id_peaje, codigo_del_peaje FROM peajes", conn)
df_peajes['codigo_peaje_normalizado'] = df_peajes['codigo_del_peaje'].apply(normalizar_codigo)
df_peajes = df_peajes.drop_duplicates(subset='codigo_peaje_normalizado')

# 8Ô∏è‚É£ Merge ahora con todos los peajes
df_merged = df.merge(df_peajes, how='left', on='codigo_peaje_normalizado')

# üîü Correcci√≥n de tipos
df_merged['valortarifa'] = df_merged['valortarifa'].astype(str).str.replace(',', '', regex=False)
df_merged['valortarifa'] = pd.to_numeric(df_merged['valortarifa'], errors='coerce')
df_merged['desde'] = pd.to_datetime(df_merged['desde'], errors='coerce')
df_merged['hasta'] = pd.to_datetime(df_merged['hasta'], errors='coerce')
df_merged['cantidadtrafico'] = pd.to_numeric(df_merged['cantidadtrafico'], errors='coerce').fillna(0).astype(int)
df_merged['cantidadexentos787'] = pd.to_numeric(df_merged['cantidadexentos787'], errors='coerce').fillna(0).astype(int)
df_merged['categoriatarifa'] = df_merged['categoriatarifa'].astype(str)


df_validos = df_merged

# 1Ô∏è‚É£2Ô∏è‚É£ Insertar en 'recaudo'
columnas_recaudo = ['id_peaje', 'desde', 'hasta', 'cantidadtrafico', 'categoriatarifa', 'valortarifa', 'cantidadexentos787']
df_final = df_validos[columnas_recaudo]

with engine.begin() as conn:
    df_final.to_sql("recaudo", con=conn, if_exists="append", index=False)
    print(f"üì• {len(df_final)} registros insertados en la tabla 'recaudo'.")


# 1Ô∏è‚É£4Ô∏è‚É£ Resumen final
print("\nüìä RESUMEN DEL CARGUE:")
print(f"üìÑ Total registros en el archivo CSV: {len(df)}")
print(f"‚úÖ Registros insertados: {len(df_final)}")
print(f"‚ûï Peajes nuevos creados: {len(peajes_nuevos)}")

"""Consulta numero de registros por tabla"""



from sqlalchemy import create_engine, text

# Tablas a consultar
tablas = ['tramos', 'peajes', 'recaudo']

# Ejecutar conteo por tabla
with engine.connect() as conn:
    for tabla in tablas:
        result = conn.execute(text(f"SELECT COUNT(*) FROM {tabla};"))
        total = result.scalar()
        print(f"üìä Total de registros en {tabla}: {total}")

"""LISTADO DE TABLAS EXISTENTES EN LA BD"""

from sqlalchemy import create_engine, text
# Consultar las tablas del esquema 'public'
with engine.connect() as conn:
    result = conn.execute(text("""
        SELECT tablename
        FROM pg_tables
        WHERE schemaname = 'public';
    """))
    tablas = result.fetchall()

# Mostrar resultado
print("üìÑ Tablas en la base de datos:")
for tabla in tablas:
    print("-", tabla[0])

with engine.connect() as conn:
  db = conn.execute(text("SELECT current_database();")).scalar()
  print(f"üìå Base de datos actual: {db}")

  with engine.connect() as conn:
    result = conn.execute(text("SELECT current_database();")).scalar()
    print(f"üìå Base actual: {result}")

    tablas = conn.execute(text("""
        SELECT schemaname, tablename FROM pg_tables WHERE schemaname NOT IN ('pg_catalog', 'information_schema');
    """)).fetchall()

print("üìÑ Tablas encontradas:")
for schema, tabla in tablas:
    print(f"- {schema}.{tabla}")

from sqlalchemy import create_engine, text
import pandas as pd

# Consulta simple a toda la tabla
with engine.connect() as conn:
    df_peajes = pd.read_sql("SELECT * FROM peajes", conn)

# Mostrar las primeras filas
print(df_peajes)

df_peajes.to_excel("peajes_completa detalle.xlsx", index=False)

"""ELIMINAR RECAUDOS - PEAJES - TRAMOS"""

from sqlalchemy import text

with engine.begin() as conn:
    conn.execute(text("DELETE FROM recaudo"))
    print("üßπ Todos los registros eliminados de la tabla 'recaudo'.")

from sqlalchemy import text

with engine.begin() as conn:
    conn.execute(text("DELETE FROM peajes"))
    print("üßπ Todos los registros eliminados de la tabla 'peajes'.")

from sqlalchemy import text

with engine.begin() as conn:
    conn.execute(text("DELETE FROM tramos"))
    print("üßπ Todos los registros eliminados de la tabla 'tramos'.")